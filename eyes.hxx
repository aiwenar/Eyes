/* Eyes
 * Copyright (C) 2011, 2012  Krzysztof Mędrzycki, Damian Chiliński
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _eyes_eyes_hxx
#define _eyes_eyes_hxx

extern const double versiond;
extern const char *verstr;

/**
 * \mainpage Eyes
 *
 * \section intro Introduction
 *
 * Some introduction to Eyes Project
 */

#include "configuration.hxx"
#include "defines.hxx"
#include "animation.hxx"
#include "camera.hxx"

#include <QWidget>
#include <QGraphicsScene>
#include <QImage>
#include <QPixmap>
#include <QBitmap>
#include <QMap>
#include <QHash>
#include <QList>
#include <QMouseEvent>
#include <QtConcurrentRun>
#include <QTimer>
#include <QThread>
#include <QTime>
#include <QElapsedTimer>
#include <QApplication>
#include <QDesktopWidget>
#include <ostream>

#include "defines.hxx"
#include "animation.hxx"
#include "configuration.hxx"
#include "camera.hxx"
#include "connection.hxx"

#define NUM_LAYERS  3

extern int  eye_swL,
            eye_shL,
            eye_swR,
            eye_shR,
            eye_mwL,
            eye_mhL,
            eye_mwR,
            eye_mhR,
            eyes_w,
            eyes_h;
extern bool images_ready;

using namespace std;

class eyes_clapper;
class eyes_looker;
class Core;
class camthread;
class connectionGate;

QString get_face_suffix ( QString face );

enum eyes_flag
{
    clapper,
};

/**
 * Main widget for eyes. Draw eyes based on state generated by \p Core.
 */
class eyes_view : public QWidget
{
    Q_OBJECT
public:
    enum Layers
    {
        HOT     = 0,
        SHY     = 1,
        SLEEPY  = 2
    };
    QString             theme;
    double              size_multiplier;

    /**
     * Construct eyes_view with color \p color.
     * @param color Color of the eyes.
     */
    explicit            eyes_view           ( QWidget * parent, /*QString color, */double size_m );
    /// Destruct eyes_view.
                        ~eyes_view          ();
    /// Called when window need to be redrawed. Redraw eyes.
    void                paintEvent          ( QPaintEvent * );
    void                closeEvent          ( QCloseEvent * ev );
    /**
     * Called by \p Core when \p bulwers is updated.
     * @param core_stats state of bulwers.
     */
    void                set_face            ( QString nface );
    void                set_eyes            ( QString neyes );
    void                set_eyes_position   ( int nx1, int nx2, int ny1, int ny2 );
    void                set_mirror_position ( double nx1, double nx2, double ny1, double ny2 );
    void                set_animation       ( QString start, QString end, int from, int to );
    void                interrupt           ();// QString nstart, QString nend, int nfrom, int nto );
    void                anims_send          ( QString fac, QString nstart, QString nend, unsigned short nfrom, unsigned short nto );
    void                send_eyes           ( QString neyes );
    void                hpp_evoke           ();
    void                toggle_layer        ( Layers layer, bool onoff );
    void                set_layer           ( Layers layer, const char * face );
    void                reload_eyes         ();
    void                graphics_prepare    ();
    void                anims_reload        ();
    void                setFlag             ( eyes_flag flag, bool value );
    void                look_at             ( int px, int py, pair<int, int> operationsarea, int looktime );
    int                 heightForWidth      ( int w )                               const;
    int                 get_next_clap_delay ();
    /// @return position x of left eye.
    inline int          get_eyes_x1         () { return epx1; }
    /// @return position x of right eye.
    inline int          get_eyes_x2         () { return epx2; }
    /// @return position y of eyes.
    inline int          get_eyes_y1         () { return epy1; }
    inline int          get_eyes_y2         () { return epy2; }
    /// @return position x of left mirror.
    inline double       get_mirror_x1       () { return mpx1; }
    /// @return position x of right mirror.
    inline double       get_mirror_x2       () { return mpx2; }
    /// @return position y of mirrors.
    inline double       get_mirror_y1       () { return mpy1; }
    inline double       get_mirror_y2       () { return mpy2; }
    QVariant            inputMethodQuery    ( Qt::InputMethodQuery query )          const;
    QSize               sizeHint            ()                                      const;
    QString             get_face            ();
    QString	            get_face_next       ();
    QString             get_color_suffix    () { return color; }
signals:
    void                mousemoved          ( int x, int y );
    void                mouseentered        ();
public slots:
    void                mousePressEvent     ( QMouseEvent * ev );
    void                mouseMoveEvent      ( QMouseEvent * ev );
    void                enterEvent          ( QMouseEvent * );
private:
    struct _layer
    {
        QString face;
        bool    drawable;
    };

    void  open_images ( const char * color );
    void  load        ( QString folder, QString alt, const char * suffix, const struct _img_loadinfo[], int num );
    _layer                * layers;
    QTimer                * timer;
    QTime                   time;
    QWidget               * win;
    QBitmap                 mask;
    QPixmap               * area;
    QPixmap                 merge_mirrors(QPixmap mask);
    QString                 eye,
                            face,
                            face_next,
                            face_queue,
                            spec,
                            color;
    QHash<QString,QPixmap*> pics;
    QHash<QString,QPixmap>  eyes;
    QFuture<void>           c_main;
    int                     px,
                            py,
                            epx1,
                            epx2,
                            epy1,
                            epy2;
    double                  mpx1,
                            mpx2,
                            mpy1,
                            mpy2;
    bool                    clapper_f,
                            dual_eyes;
    void                  * locker;
    eyes_clapper          * clapper;
    eyes_looker           * looker;
    Configuration         * set;
    Core                  * core;
    camthread             * camt;
    pair<int, int>          screensize;
};

/**
 * Module that controll claping animations.
 */
class eyes_clapper : public QThread
{
    Q_OBJECT
public:
    /**
     * Construct \p eyes_clapper.
     * @param neyes pointer to \p eyes_view to controll.
     */
    explicit    eyes_clapper        ( eyes_view * neyes );
    int         get_next_clap_delay ();
    /// Start timer.
    void        run                 ();
    /// Sets actual animation.
    void        set_animation       ( QString nstart, QString nend, int nfrom, int nto );
    /// interrupts current animation and replaces it with a new one
    void        interrupt           ();// QString nstart, QString nend, int nfrom, int nto );
public slots:
    /// Called on timer tick, ...?.
    void        clap                ();
private:
    int                         stage,
                                from,
                                to,
                                size1,
                                size2,
                                min_dl,
                                max_dl;
    eyes_view                 * eyes;
    QTime                       time;
    QTimer                    * timer;
    QString                     face,
                                start,
                                end;
    QMap<QString,animation*>    animations;
};

/**
 * Module that controll eyes looking.
 */
class eyes_looker : public QObject
{
    Q_OBJECT
public:
    /**
     * Construct \p eyes_looker.
     * @param neyes pointer to \p eyes_view to controll.
     */
            eyes_looker ( eyes_view * eyes );
    void    run       ();
    void    interrupt ( int x, int y, int looktime );
public slots:
    /// Called on timer tick, ...?.
    void    look ();
private:
    void  look_at ( int dx, int dy );

    eyes_view * eyes;
    QTimer    * timer;
    int         min_dx,
                max_dx,
                min_dy,
                max_dy,
                min_dl,
                max_dl,
                bmin_x,
                bmax_x,
                bmin_y,
                bmax_y;
};

class cdbg;

class Core : public QObject
{
    Q_OBJECT
public:
                    Core            ( eyes_view * );
                    Core            ();
                    ~Core           ();
    void            bulwers_update  (),
                    bulwers_init    (),
                    load_config     (),
                    run             (),
                    graphics_prepare(),
                    autocalc_reload ( Configuration * set ),
                    autocalc_init   ();

    bool            core_only_mode,
                    cdbg_enabled,
                    hdbg_enabled;
    connectionGate * con;

    QString face_prev;

    friend class cdbg;
public slots:
    void    on_timer_tick   ();
    void    handle_mouse    ( int x, int y );
    void    handle_enter    ();
private:
    QTimer        * timer;
    eyes_view     * eyes;
    cdbg          * _cdbg;
};

class camthread : public QThread
{
    Q_OBJECT
public:
                      camthread( eyes_view * );
    void              run ();
    QTimer          * timer;
    QElapsedTimer     speedmeter;
    eyes_view       * eyes;
public slots:
    void        tick();
};

extern eyes_view * eyes;

#endif //eyes_eyes_hxx
